---
title: Implement Custom Data Pipelines
source: https://developer.ordergroove.com/docs/implement-custom-data-pipelines
converted_from: html
---

# Implement Custom Data Pipelines

## Ordergroove 101

*   [Developer Fundamentals](/docs/developer-fundamentals)
    *   [Systems Landscape Map](/docs/landscape-map)
    *   [Data model at a glance](/docs/data-model-at-a-glance)
    *   [Subscription Creation via Purchase POST](/docs/subscription-creation-via-purchase-post)
    *   [Recurring Order Placement](/docs/recurring-order-placement)
    *   [Subscription Manager Tagging and Authentication](/docs/subscription-manager-tagging-and-authentication)
    *   [Customer and Payment Updates](/docs/customer-and-payment-updates)
*   [General FAQ](/docs/general-faq)
*   [Install Ordergroove on an Online Store 2.0 theme](/docs/use-ordergroove-with-online-store-20)
    *   [Installing Ordergroove with App Embed](/docs/installing-ordergroove-with-app-embed)
*   [Custom Platform and Headless Subscription Implementation](/docs/integrating-with-a-custom-platform-1)

## Program Migration

*   [Migrate my data to Ordergroove](/docs/program-migration)
*   [Self-serve migration guide](/docs/view-self-serve-migration-guide)
*   [Self-serve migration guide for Recharge](/docs/self-serve-migration-guide-for-recharge)
*   [Staged Migrations](/docs/staged-migrations)

## Syncing Ordergroove Data

*   [Sync Ordergroove Data into Internal Systems](/docs/sync-ordergroove-data-into-internal-systems)
*   [Sync Objects](/docs/implement-custom-data-pipelines)
    *   [Implement Custom Data Pipelines](/docs/implement-custom-data-pipelines)
    *   [Using Prebuilt Connectors](/docs/using-prebuilt-connectors)
    *   [SFTP File Drops](/docs/sftp-file-drops)
*   [Sync Events](/docs/sync-events)

## Product Catalog

*   [Offer Tagging](/docs/offer-tagging)
*   [Product Feed](/docs/integrating-with-a-custom-platform)

## Subscription Enrollment

*   [Getting started](/docs/getting-started)
*   [First Order Place Date control for Shopify Merchants](/docs/first-order-place-date-control-for-shopify-merchants)
*   [Showing Discounted Price](/docs/showing-discounted-price-in-shopify)
*   [Customizing the Initial Offer Incentive (IOI)](/docs/customizing-the-initial-offer-incentive-ioi-using-shopify-scripts)
*   [Free shipping on initial orders](/docs/free-shipping-on-initial-orders-with-shopify-scripts)
*   [Cart Opt-In Tagging](/docs/shopify-cart-opt-in-tagging)
*   [Tagging the Product Details Page (PDP)](/docs/tagging-the-product-details-page-pdp)
*   [Real Time Stock Update](/docs/real-time-stock-update)
*   [Add a subscription to cart](/docs/modify-a-subscription-from-checkout-flow)
    *   [Offer Code Elements](/docs/offer-code-elements)
    *   [Domain Objects](/docs/domain-objects)
    *   [Helper Methods](/docs/helper-methods)
*   [Add a subscription offer to quickview, homepage, or other areas of your site](/docs/quickview-offers)
    *   [Tracking Affiliate Codes on Recurring Orders](/docs/tracking-affiliate-codes-on-recurring-orders)
*   [Troubleshooting Cart Offers](/docs/troubleshooting-cart-offers)
*   [Modify a subscription from email and SMS](/docs/modify-a-subscription-from-email-and-sms)
*   [Advanced Offer Customizations & FAQ](/docs/advanced-offer-customizations-faq)

## Subscription Manager Overview

*   [Subscription Manager From The Customer's Perspective](/docs/getting-started-1)
*   [Tour of Subscription Manager v25](/docs/tour-of-subscription-manager-v25)
    *   [Intro to v25 for Developers transitioning from v0](/docs/intro-to-v25-for-developers-transitioning-from-v0)
    *   [Customizing calendars and dates in v25](/docs/customizing-calendars-and-dates-in-v25)
    *   [Understanding Subscription Manager Custom Elements](/docs/understanding-subscription-manager-custom-elements)
*   [Subscription Manager File Descriptions](/docs/subscription-manager-file-descriptions)
*   [Subscription Manager v0 Components & Containers](/docs/subscription-manager-components-containers)
    *   [Subscription Manager Templates](/docs/subscription-manager-templates)
    *   [Orders Unsent Section](/docs/orders-unsent-section)
        *   [Skip Order](/docs/skip-order)
        *   [Send Now](/docs/send-now)
        *   [Change Date](/docs/change-date)
    *   [Orders Processing Section](/docs/orders-processing-section)
    *   [Inactive Subscriptions Section](/docs/inactive-subscriptions-section)
*   [Customize your Subscription Manager templates without breaking tracking](/docs/sm-template-customization-tracking)
*   [Subscription Manager Templates Changelog](/docs/subscription-manager-templates-changelog)

## Subscription Manager Modifications

*   [Subscription Manager Development Overview](/docs/subscription-manager-overview)
    *   [Edit Code with the Advanced Editor](/docs/edit-code-with-the-advanced-editor)
    *   [Subscription Manager Theme Editor Overview](/docs/subscription-manager-theme-editor-overview)
    *   [Subscription Manager Development Guide](/docs/subscription-manager-development-guide)
    *   [Customizing Subscription Manager Sections on Shopify](/docs/customizing-subscription-manager-sections-on-shopify)
    *   [Refreshing data in the Subscription Manager](/docs/refreshing-data-in-the-subscription-manager)
    *   [Objects](/docs/objects)
    *   [Object Reference](/docs/object-reference)
    *   [Translations](/docs/translations)
    *   [Subscription Manager Local Development](/docs/subscription-manager-local-development)
    *   [Debugging with Redux](/docs/debugging-with-redux)
    *   [Working with dates in the Subscription Manager](/docs/working-with-dates-in-the-subscription-manager)
*   [Modify the Change Billing Process Button](/docs/modify-the-change-billing-process-button)
*   [Implementing Country & State Dropdown in Subscription Manager Themes](/docs/implementing-country-state-dropdown-in-subscription-manager-themes)
*   [Adding a Cancel Button to Modals](/docs/adding-a-cancel-button-to-modals)
*   [Limiting Future Dates in the Change Date Calendar](/docs/limiting-future-dates-in-the-change-date-calendar)
*   [Dynamic Shipping Restrictions in the Subscription Manager](/docs/dynamic-shipping-restrictions-in-the-subscription-manager)
*   [One Time SKU Swap Configuration in the Subscription Manager](/docs/one-time-sku-swap-configuration-in-the-subscription-manager)
*   [Adding a Scrollbar to Inactive Subscriptions in the Subscription Manager](/docs/adding-a-scrollbar-to-inactive-subscriptions-in-the-subscription-manager)
*   [Enabling Payment Updates for Shopify New Accounts](/docs/enabling-payment-updates-for-shopify-new-accounts)

## Subscription Manager Development with APIs

*   [Calling Ordergroove‚Äôs REST APIs from within Subscription Manager](/docs/call-rest-apis-from-within-subscription-manager)
*   [Integrating External APIs in the Subscription Manager](/docs/integrating-external-apis-in-the-subscription-manager)

## Tagging Subscription Manager

*   [Tagging the Subscription Manager](/docs/tagging-the-subscription-manager-on-shopify)
*   [Convert your customers/account page to support Online Store 2.0](/docs/convert-your-customersaccount-page-to-support-online-store-20)

## Upsell and 1-Click

*   [Instant Upsell Overview](/docs/getting-started-2)
    *   [Instant Upsell through API](/docs/add-a-one-time-item-to-an-upcoming-order)
*   [1-Click Actions in Emails](/docs/1-click-actions-in-emails)

## Subscription Types

*   [Bundle Subscriptions](/docs/bundle-subscriptions)
    *   [Configuring Bundles](/docs/configuring-bundles)
    *   [Box Subscription Creation on Shopify](/docs/box-subscription-creation-on-shopify)
    *   [Bundle API Components](/docs/bundle-api-components)
    *   [Build Your Own Box Subscriptions (Legacy)](/docs/build-your-own-box-subscriptions)
        *   [Shopify - Build Your Own Box Subscriptions (Legacy)](/docs/build-your-own-box-subscriptions-on-shopify)
*   [Guided Selling](/docs/guided-selling)
*   [Curation Subscriptions: Rotating Box or Club](/docs/curation-subscriptions-rotating-box-or-club)
*   [Prepaid Subscriptions](/docs/how-to-manage-prepaid-renewal-behaviors)
    *   [How to Manage Prepaid Renewal Behaviors](/docs/how-to-manage-prepaid-renewal-behaviors)
*   [Rotating Subscriptions](/docs/rotating-subscriptions)
    *   [Ordinal Based Rotating Products](/docs/ordinal-based-rotating-products)
    *   [Time Window Based Rotating Products](/docs/time-window-based-rotating-products)
*   [Digital Subscriptions](/docs/digital-subscriptions)

## program data

*   [Configuring PayPal](/docs/configuring-paypal)
*   [Removing Ordergroove code from your Shopify theme](/docs/removing-ordergroove-code-from-your-shopify-theme)
*   [Webhooks overview (Legacy)](/docs/via-webhooks)
    *   [Configure Webhooks via API](/docs/configure-webhooks-via-api)
    *   [Expiring or Termed Subscriptions Using Webhooks](/docs/expiring-or-termed-subscriptions-using-webhooks)
*   [HMAC and AES Authentication](/docs/hmac-and-aes-authentication)

# Implement Custom Data Pipelines

[Suggest Edits](/edit/implement-custom-data-pipelines)

This article provides a guide on how to set up your own custom data pipelines to sync Ordergroove data using Ordergroove Rest APIs. This article provides a detailed walk through of fetching data, handling pagination, scheduling ETL jobs.

* * *

## 

Architecture Template

[](#architecture-template)

Ordergroove recommends the following steps around how to architect the ingestion:

1.  Schedule a job that triggers an Ordergroove data sync.
2.  Configure a separate thread for each endpoint (subscriptions, items, orders, etc.), call the API with `updated_start` set to the start time of the last sync as a cutoff timestamp.
3.  Page through all results using the cursor-based pagination until all new data is retrieved.
4.  Load the data into the warehouse, upserting into destination tables.
5.  Store the start time of this job in your system to use it as an update timestamp filter for the next run.

* * *

## 

API Access and Prerequisites

[](#api-access-and-prerequisites)

Before you can sync data, make sure you have the proper API access:

1.  **API Key**: Ordergroove uses API key authentication for its APIs. See [Authentication](/reference/authentication#key-retrieval-and-sample-code) for more information.
2.  **Permissions**: Your API key must have the ‚ÄúBulk‚Äù scope/permissions to read the data for data syncing. Test your key with a simple call (e.g., list customers) to verify access. If you receive 401/403 errors, check that the key is correct and has read permissions.
3.  **Testing Environment**: If you have a staging Ordergroove environment, you might first test your pipelines against the test environment.
4.  **Data Model Understanding**: Familiarize yourself with the JSON structure of each endpoint by reviewing the [Ordergroove API reference](/reference/introduction) or making sample calls. Understanding these fields helps in designing your warehouse schema (e.g. you might have separate tables for orders and order\_items, linked by an order ID).
5.  **Logging and Monitoring**: Implement logging for each sync run, including the number of records fetched and timestamps. This helps in troubleshooting if something goes wrong (e.g., if an expected update was missed, you can check if it was fetched or not).

* * *

## 

Reference ‚Äì API Endpoints and Capabilities

[](#reference--api-endpoints-and-capabilities)

Below is a reference table of the main Ordergroove API endpoints for data sync, indicating which support the incremental fetch using `updated_start` filter for incremental loads and which support cursor-based pagination (API v2):

Endpoint (GET list)

Supports Incremental Fetch updated\_start

[Cursor-Based Pagination](/reference/pagination#:~:text=Fetching%20Additional%20Results%20with%20Cursor,Pagination)

[Customers](/reference/customers-list) (/customers/)

Yes ‚Äì filter by updated datetime is available.

Yes

[Subscriptions](/reference/subscriptions-list) (/subscriptions/)

Yes ‚Äì filter by updated datetime is available.

Yes

[Orders](/reference/orders-list) (/orders/)

Yes ‚Äì filter by updated datetime is available.

Yes

[Items](/reference/items-list) (/items/)

Yes ‚Äì filter by updated datetime is available - the filter is named **‚Äúorder\_updated\_start‚Äù**

Yes

[Addresses](/reference/addresses-list) (/addresses/)

Yes ‚Äì filter by updated datetime is available

Yes

[Payments](/reference/payments-list) (/payments/)

**No** ‚Äì `updated_start` not supported (must fetch all).

Yes

[Products](/reference/products-list) (/products/)

**No** ‚Äì `updated_start` not supported (must fetch all).

Yes

[Offer Profiles](/reference/offer-profile-list) (/offer\_profiles/)

**No** ‚Äì `updated_start` not supported (must fetch all).

Yes

[One-Time Incentives](/reference/otd-list) (/one\_time\_incentives/)

**No** ‚Äì `updated_start` not supported (must fetch all).

Yes

**Notes:**

*   For Products and Payments since Ordergroove keeps a copy of what‚Äôs already in the ecommerce system, you should not need to sync this data
*   All ‚ÄúYes‚Äù for cursor-based pagination assumes you include the `X-OG-API-VERSION: 2` header on your requests ‚Äã[developer.ordergroove.com](/reference/pagination#:~:text=Cursor%20Based%20Pagination%20in%20List,Endpoints). Without that, the API might default to an older page-index method **(not recommended)**.

* * *

## 

Use Incremental Fetch Logic with `updated_start field`

[](#use-incremental-fetch-logic-with-updated_start-field)

Incremental sync means fetching only records that have changed (created or updated) since your last sync run, rather than pulling all data every time. Using incremental fetch will allow you run the job faster and will cost less in terms of time and resources to keep your data fresh. Ordergroove‚Äôs list endpoints support filtering by an update timestamp except Payments and Products list endpoints. The key query parameter is `updated_start`, which accepts a date-time (CST timezone) and returns all objects updated _on or after_ that timestamp. This allows you to pick up new and modified records incrementally.

**How to use updated\_start**: For each API resource, specify `?updated_start=<datetime>` in the request. For example, to fetch subscriptions updated since January 1, 2025, you would call:

`GET /subscriptions/?updated_start=2025-01-01T12:00:00`

This would return all subscriptions whose `updated` date is 2025-01-01 (CST) or later. On initial creation, an object‚Äôs updated timestamp is set to its created date, so newly created records are captured by the filter as well. Typically, you would store the start time of the last sync timestamp in your system, and on the next run use that as the `updated_start` to fetch changes.

**Exceptions:**

**Products, Payments, OfferProfiles and OneTimeDiscounts** list endpoints do not provide incremental fetch options, so if you need to pull these you will need to do a full refresh.

This is due to a combination of practical usage patterns and data volume considerations:

*   Products and Payments are typically sourced directly from the merchant's commerce platform (e.g., Shopify, Salesforce, etc.), and are often available in the merchant‚Äôs primary system of record. As a result, most merchants do not rely on Ordergroove as the authoritative source for this data, and incremental sync for these endpoints has not been prioritized.
*   Offer Profiles and One-Time Discounts are relatively lightweight datasets, and their size makes it feasible to retrieve the full set on each sync. A full refresh is efficient and does not pose performance concerns.

Support for incremental sync on these endpoints may be considered in the future based on demand and evolving merchant use cases, but as of now, full refresh is the recommended approach.

* * *

## 

How to set up Initial Sync and Full Refresh

[](#how-to-set-up-initial-sync-and-full-refresh)

> ## üìò
> 
> Not all merchants need to backfill data. If you're launching a new subscription program or don't have historical subscription data to import, you can skip this step.

In order to set up an initial sync (or any full refresh), you simply omit the `updated_start` parameter to fetch all records from an endpoint. This will retrieve the entire history/dataset for that resource. In practice, the API call is the same as incremental ‚Äì e.g. `GET /orders/` without any date filters will return all orders.

If you experience longer response times (e.g >20s), you might perform the initial load in segments (for instance, by using `updated_start and updated_end` with yearly, or monthly ranges) to reduce response time but otherwise using the pagination (discussed next) is sufficient. After the initial load, you‚Äôll switch to using `updated_start` with the last updated timestamp from your warehouse to only get new/changed records going forward.

### 

Pagination (Cursor-Based)

[](#pagination-cursor-based)

You should only use cursor based pagination with Rest APIs for data syncing use case, which ensures stable paging even as data changes. By default, a list request returns 10 results if not specified, but you can control the page size up to 100 records using the `page_size` parameter‚Äã [developer.ordergroove.com](/reference/pagination#:~:text=By%20default%2C%20List%20endpoints%20return,results). When there are more records to fetch, the response will include a `next` URL (and a `previous` URL if applicable) containing a `cursor` parameter ‚Äã[developer.ordergroove.com](/reference/pagination#:~:text=Fetching%20Additional%20Results%20with%20Cursor,Pagination). To get the subsequent page of results, you simply make a request to the `next` URL provided. This `cursor` is an opaque pointer that the server uses to maintain your position in the dataset.

You can read more on how to use Cursor based pagination [here](/reference/pagination#:~:text=Fetching%20Additional%20Results%20with%20Cursor,Pagination).

**Do not use page-index based pagination** (e.g. `?page=2`) as it is deprecated and can lead to inconsistencies ‚Äì always stick to the cursor method with API v2. Cursor pagination ensures you won‚Äôt miss or duplicate records if new updates arrive during paging‚Äã

### 

ETL Scheduling and Automation

[](#etl-scheduling-and-automation)

We recommend scheduling an incremental daily data sync between 12pm CST and 8pm CST, when most order placement activity has completed. This helps ensure you capture a full day of data. If more fresh insights are needed you can schedule it twice a day.

Many teams use orchestrators like [Airflow](https://airflow.apache.org/docs/) or simple cron jobs to run incremental syncs.

* * *

## 

Handling Deleted Data (API Limitations)

[](#handling-deleted-data-api-limitations)

In certain cases, Ordergroove will delete future, unprocessed Order and Item records from the system. This happens when a customer takes an action that changes the lifecycle of a subscription or an order, e.g:

*   A customer cancels their subscription, and any upcoming orders that haven‚Äôt yet been processed are removed.
*   A subscription‚Äôs next order date is skipped or delayed, causing previously scheduled (but not yet fulfilled) items or orders to be deleted.

While these deletions are expected and part of normal subscription management behavior, one key limitation of the Ordergroove REST API is that deleted Order and Item records that item will no longer appear in list API and there‚Äôs no ‚Äútombstone‚Äù flag via the API to indicate it was removed. That means if you're syncing data via API polling, these deletions won't be reflected in your warehouse or destination system unless you capture them separately through webhooks. Support for syncing deleted records is on the roadmap and expected by the end of 2025.

**Solution ‚Äì Webhooks for Order and Item deletions**: Ordergroove provides a robust Webhooks system that can notify your application of events in real-time. We recommend that your systems subscribe to the two webhook events ‚Äúorder.delete‚Äù and ‚Äúitem.remove‚Äù (in addition to your API sync) to account for these deletions and removals.

*   _Order.Delete_: You can subscribe to a ‚ÄúOrder.Delete‚Äù or ‚Äúsubscription expired‚Äù event‚Äã which tells you an order was deleted. Upon receiving this, you could mark that Order as deleted in your system.
*   _Item.Remove_: This will tell you when an item is deleted. Use this to delete or flag the item record in your database.

By capturing webhook payloads, you can perform a soft delete or flagging of records in your warehouse that are no longer active. This approach complements the incremental API sync: the API keeps your data updated for new and modified records, while webhooks inform you of removals that the next API poll might not catch.

* * *

## 

Best Practices

[](#best-practices)

If you're building a custom data pipeline with Ordergroove's APIs, keep these tips in mind to ensure reliable, efficient syncing:

*   Use Cursor-Based Pagination
*   Do Incremental Fetch with Timestamps
*   Implement Upsert Logic
*   Test with Smaller Time Window
*   Logging and Monitoring
*   No Concurrent requests for the same object
*   Don‚Äôt Assume Deleted Data via API
*   Rate Limit Awareness

Updated 3 months ago

* * *

*   [Table of Contents](#)
*   *   [Architecture Template](#architecture-template)
    *   [API Access and Prerequisites](#api-access-and-prerequisites)
    *   [Reference ‚Äì API Endpoints and Capabilities](#reference--api-endpoints-and-capabilities)
    *   [Use Incremental Fetch Logic with `updated_start field`](#use-incremental-fetch-logic-with-updated_start-field)
    *   [How to set up Initial Sync and Full Refresh](#how-to-set-up-initial-sync-and-full-refresh)
        *   [Pagination (Cursor-Based)](#pagination-cursor-based)
        *   [ETL Scheduling and Automation](#etl-scheduling-and-automation)
    *   [Handling Deleted Data (API Limitations)](#handling-deleted-data-api-limitations)
    *   [Best Practices](#best-practices)
